!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).MCTS=t()}(this,(function(){"use strict";const e={randomElement:e=>e[Math.floor(Math.random()*e.length)],remove:(e,t)=>{let n=t;const o=t.indexOf(e);return o>-1&&(n=[...t],n.splice(o,1)),n}};Object.freeze(e);const t={},n=Math.sqrt(2),o=(e,t)=>parseFloat(e)-parseFloat(t);t.MAX_NUMBER=1e6,t.create=({game:e,children:t=[],isGameOver:n=!1,move:o=null,parent:r,playoutCount:a=0,winCount:i=0,winner:s=null})=>({children:t,game:e,isGameOver:n,move:o,parent:r,playoutCount:a,winCount:i,winner:s}),t.accept=(e,n)=>{if(n.visit(e),e.children.length>0){const o=e=>t.accept(e,n);R.forEach(o,e.children)}},t.best=(t,n)=>{let r;if(n)if(1===n.length)[r]=n;else{const a=R.groupBy(t,n),i=Object.keys(a);i.sort(o);const s=a[R.last(i)];r=1===s.length?s[0]:e.randomElement(s)}return r},t.exploitation=e=>{const n=e.playoutCount;return 0===n?t.MAX_NUMBER:e.winCount/n},t.exploration=e=>{const o=e.playoutCount;if(0===o)return t.MAX_NUMBER;const r=e.parent?Math.max(e.parent.playoutCount,1):1;return n*Math.sqrt(Math.log(r)/o)},t.root=e=>{let t=e;for(;t&&t.parent;)t=t.parent;return t},t.uct=e=>t.exploitation(e)+t.exploration(e),Object.freeze(t);const r={execute:(e,n)=>{const o=t.root(n),{game:r}=o,a=r.getCurrentPlayer();let i=n;for(;i&&a;)R.isNil(e)?i.winCount+=.5:e===a&&(i.winCount+=1),i.playoutCount+=1,i=i.parent}};Object.freeze(r);const a={execute:n=>{const o=n,{game:r}=o,a=r.getPossibleMoves();return o.children=R.map(e=>{const n=r.clone();return n.performMove(e),t.create({game:n,move:e,parent:o})},a),e.randomElement(o.children)}};Object.freeze(a);const i={execute:e=>{let n=e;for(;n.children.length>0;)n=t.best(t.uct,n.children);return n}};Object.freeze(i);const s={execute:(t,n=100)=>{const{game:o}=t,r=o.clone();let a=1,i=r.getPossibleMoves(),s=r.getWinner();for(;!s&&a<n&&i.length>0;){const t=e.randomElement(i);r.performMove(t),a+=1,s=r.getWinner(),i=r.getPossibleMoves()}return s}};Object.freeze(s);class c{constructor({game:e,selection:t=i,expansion:n=a,simulation:o=s,backpropagation:c=r}){this._game=e,this._selection=t,this._expansion=n,this._simulation=o,this._backpropagation=c}executeSteps(e,n,o,r,a){let i=Date.now();for(;i-e<a;){const e=this._selection.execute(n),t=e.isGameOver||e.game.isGameOver();if(t){const n=e.winner||e.game.getWinner();e.isGameOver=t,e.winner=n,this._backpropagation.execute(n,e)}else{const t=this._expansion.execute(e),n=this._simulation.execute(t,r);this._backpropagation.execute(n,t)}i=Date.now()}o((e=>{const n=t.best(R.prop("playoutCount"),e.children,!0);return n?n.move:void 0})(n))}execute(e=100,n=1e3){return new Promise(o=>{const r=Date.now(),a=t.create({game:this._game});this.executeSteps(r,a,o,e,n)})}}Object.freeze(c);const l={};return l.Node=t,l.Selection=i,l.Expansion=a,l.Simulation=s,l.Backpropagation=r,l.MonteCarloTreeSearch=c,Object.freeze(l),l}));
