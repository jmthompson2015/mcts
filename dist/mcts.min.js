!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).MonteCarloTreeSearch=t()}(this,(function(){"use strict";const e={randomElement:e=>e[Math.floor(Math.random()*e.length)],remove:(e,t)=>{let n=t;const o=t.indexOf(e);return o>-1&&(n=[...t],n.splice(o,1)),n}};Object.freeze(e);const t={},n=Math.sqrt(2),o=(e,t)=>parseFloat(e)-parseFloat(t);t.MAX_NUMBER=1e6,t.create=({game:e,children:t=[],isGameOver:n=!1,parent:o,playoutCount:r=0,winCount:s=0,winner:a=null})=>({children:t,game:e,isGameOver:n,parent:o,playoutCount:r,winCount:s,winner:a}),t.accept=(e,n)=>{if(n.visit(e),e.children.length>0){const o=e=>t.accept(e,n);R.forEach(o,e.children)}},t.best=(t,n)=>{let r;if(n)if(1===n.length)[r]=n;else{const s=R.groupBy(t,n),a=Object.keys(s);a.sort(o);const c=s[R.last(a)];r=1===c.length?c[0]:e.randomElement(c)}return r},t.exploitation=e=>{const n=e.playoutCount;return 0===n?t.MAX_NUMBER:e.winCount/n},t.exploration=e=>{const o=e.playoutCount;if(0===o)return t.MAX_NUMBER;const r=e.parent?Math.max(e.parent.playoutCount,1):1;return n*Math.sqrt(Math.log(r)/o)},t.root=e=>{let t=e;for(;t&&t.parent;)t=t.parent;return t},t.uct=e=>t.exploitation(e)+t.exploration(e),Object.freeze(t);const r={execute:(e,n)=>{const o=t.root(n),{game:r}=o,s=r.getCurrentPlayer();let a=n;for(;a&&s;)R.isNil(e)?a.winCount+=.5:e===s.team&&(a.winCount+=1),a.playoutCount+=1,a=a.parent}};Object.freeze(r);const s={execute:(n,o)=>{const r=n,{game:s}=r,a=s.getPossibleMoves();return r.children=R.map(e=>{const n=Immutable({...s.state,currentMoves:a,currentMove:e}),c=new o(n);return c.performMove(e),t.create({game:c,parent:r})},a),e.randomElement(r.children)}};Object.freeze(s);const a={execute:e=>{let n=e;for(;n.children.length>0;)n=t.best(t.uct,n.children);return n}};Object.freeze(a);const c={execute:(t,n=100)=>{const{game:o}=t,r=o.clone();let s=1,a=r.getPossibleMoves(),c=r.getWinner();for(;!c&&s<n&&a.length>0;){const t=e.randomElement(a);r.performMove(t),s+=1,c=r.getWinner(),a=r.getPossibleMoves()}return c}};Object.freeze(c);class i{constructor(e,t=a,n=s,o=c,i=r){this._gameClass=e,this._selectionClass=t,this._expansionClass=n,this._simulationClass=o,this._backpropagationClass=i}executeSteps(e,n,o,r,s){let a=Date.now();for(;a-e<s;){const e=this._selectionClass.execute(n),t=e.isGameOver||e.game.isGameOver();if(t){const n=e.winner||e.game.getWinner();e.isGameOver=t,e.winner=n,this._backpropagationClass.execute(n,e)}else{const t=this._expansionClass.execute(e,this._gameClass),n=this._simulationClass.execute(t,r);this._backpropagationClass.execute(n,t)}a=Date.now()}o((e=>{const n=t.best(R.prop("playoutCount"),e.children,!0);let o;if(n){const{game:e}=n,{state:t}=e;o=t.currentMove}return o})(n))}execute(e,n=100,o=5e3){return new Promise(r=>{const s=Date.now(),a=t.create({game:e});this.executeSteps(s,a,r,n,o)})}}return Object.freeze(i),i}));
