!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).MCTS=t()}(this,(function(){"use strict";const e={randomElement:e=>e[Math.floor(Math.random()*e.length)],remove:(e,t)=>{let n=t;const o=t.indexOf(e);return o>-1&&(n=[...t],n.splice(o,1)),n}};Object.freeze(e);const t={},n=Math.sqrt(2),o=(e,t)=>parseFloat(e)-parseFloat(t);t.MAX_NUMBER=1e6,t.create=({game:e,children:t=[],isGameOver:n=!1,move:o=null,parent:r,playoutCount:i=0,winCount:a=0,winner:s=null})=>({children:t,game:e,isGameOver:n,move:o,parent:r,playoutCount:i,winCount:a,winner:s}),t.accept=(e,n)=>{if(n.visit(e),e.children.length>0){const o=e=>t.accept(e,n);R.forEach(o,e.children)}},t.best=(t,n)=>{let r;if(n)if(1===n.length)[r]=n;else{const i=R.groupBy(t,n),a=Object.keys(i);a.sort(o);const s=i[R.last(a)];r=1===s.length?s[0]:e.randomElement(s)}return r},t.exploitation=e=>{const n=e.playoutCount;return 0===n?t.MAX_NUMBER:e.winCount/n},t.exploration=e=>{const o=e.playoutCount;if(0===o)return t.MAX_NUMBER;const r=e.parent?Math.max(e.parent.playoutCount,1):1;return n*Math.sqrt(Math.log(r)/o)},t.root=e=>{let t=e;for(;t&&t.parent;)t=t.parent;return t},t.uct=e=>t.exploitation(e)+t.exploration(e),Object.freeze(t);const r={execute:(e,n)=>{const o=t.root(n),{game:r}=o,i=r.getCurrentPlayer();let a=n;for(;a&&i;)R.isNil(e)?a.winCount+=.5:e===i&&(a.winCount+=1),a.playoutCount+=1,a=a.parent}};Object.freeze(r);const i={execute:n=>{const o=n,{game:r}=o,i=r.getPossibleMoves();return o.children=R.map(e=>{const n=r.clone();return n.performMove(e),t.create({game:n,move:e,parent:o})},i),e.randomElement(o.children)}};Object.freeze(i);const a={execute:e=>{let n=e;for(;n.children.length>0;)n=t.best(t.uct,n.children);return n}};Object.freeze(a);const s={execute:(t,n=100)=>{const{game:o}=t,r=o.clone();let i=1,a=r.getPossibleMoves(),s=r.getWinner();for(;!s&&i<n&&a.length>0;){const t=e.randomElement(a);r.performMove(t),i+=1,s=r.getWinner(),a=r.getPossibleMoves()}return s}};Object.freeze(s);class c{constructor({game:e,selection:t=a,expansion:n=i,simulation:o=s,backpropagation:c=r}){if(R.isNil(e))throw new Error("MCTS constructor(): game is required");this._game=e,this._selection=t,this._expansion=n,this._simulation=o,this._backpropagation=c}executeSteps(e,n,o,r,i){let a=Date.now();for(;a-e<i;){const e=this._selection.execute(n),t=e.isGameOver||e.game.isGameOver();if(t){const n=e.winner||e.game.getWinner();e.isGameOver=t,e.winner=n,this._backpropagation.execute(n,e)}else{const t=this._expansion.execute(e);if(!R.isNil(t)){const e=this._simulation.execute(t,r);this._backpropagation.execute(e,t)}}a=Date.now()}o((e=>{const n=t.best(R.prop("playoutCount"),e.children,!0);return n?n.move:void 0})(n))}execute(e=100,n=1e3){return new Promise(o=>{const r=Date.now(),i=t.create({game:this._game});this.executeSteps(r,i,o,e,n)})}}Object.freeze(c);const l={};return l.Node=t,l.Selection=a,l.Expansion=i,l.Simulation=s,l.Backpropagation=r,l.MonteCarloTreeSearch=c,Object.freeze(l),l}));
